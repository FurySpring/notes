## 面向对象设计原则

所有的原则都是为了实现面向对象设计的可扩展性，可复用性，可维护性而定义。

1. ### 单一职责原则Single Responsibility Principle, SRP

   ##### 一个类只负责一个功能领域中的相应职责，或者定义为：就一个类而言，应该只有一个引起它变化的原因。

   单一职责原则是实现**高内聚、低耦合**的指导方针。

2. ### 开闭原则Open-Closed Principle, OCP

   ##### 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下扩展。

   软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。

   **抽象化是开闭原则的关键**。

   在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。

3. ### 里氏替换原则Liskov Substitution Principle,LSP

   ##### 所有引用基类（父类）的地方必须能透明地使用其子类的对象。

   在软件中讲一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，name它不一定能够使用基类对象。

   里氏替换原则是实现开闭原则的重要方式之一，由于使用几类对象的地方都可以使用子类对象，因此**在程序中尽量使用基类类型来定义对象，而在运行时再确定其子类类型，用子类对象替换父类对象**。

   注意：

   (1)子类必须实现父类中声明的所有方法。根据里氏替换原则，为了保证系统的扩展性，在程序中通常使用父类来定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。

   (2)运用里氏替换原则时，尽量把父类设计为抽象类或者借口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，可以很方便地扩展系统功能，同时无需修改原有子类的代码。增加新的功能可以通过增加一个新的子类来实现。

   (3)Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏替换原则，这是一个与实现无关的、纯语法意义上的检查。

4. ### 依赖倒转原则Dependency Inversion Principle, DIP

   ##### 抽象不应该依赖于细节，细节应该依赖于抽象。换言之，要针对借口编程，而不是针对实现编程。

   如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。

   依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要具体类来做这些事情。

   在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过**依赖注入(Dependency Injection,DI)**的方式注入到其他对象中，**依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入要依赖的对象**。常用的注入方式有三种：**构造注入**，**设值注入(Setter)**和**接口注入**。

   **开闭原则是目标，里氏替换原则是基础，依赖倒转原则是手段**。它们相辅相成，相互补充，目标一致，只是分析问题时所站的角度不同而已。

5. ### 接口隔离原则Interface Segregation Principle, ISP

   ##### 使用多个专用的接口，而不是单一的总接口，即客户端不需要依赖那些它不需要的接口。

   每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的都要干。

   **接口**：一种指一个类型所具有的方法特征集合，一种逻辑上的抽象；另一种指某种具体语言具体的接口；

   (1)广义上的接口，这就是一种逻辑上的概念，接口的划分将带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口。此时，这个原则可以叫「角色隔离原则」。

   (2)特定语言的接口，ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来。应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也成为「定制服务」。

   在使用接口隔离原则时，我们需要注意控制接口的粒度。接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性差，使用起来很不方便。

6. ### 合成/聚合复用原则Composite/Aggregation Reuse Principle, CARP

   ##### 尽量使用对象组合，而不是继承来达到复用的目的。

   合成复用原则就是在一个新的对象里通过关联关系（组合/聚合）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用的目的。简言之：复用时要尽量使用组合/聚合关系，少用继承。

   在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合或通过继承，但首先应该考虑使用组合/聚合。组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏替换原则。有效使用继承会有助于理解问题，降低复杂度。而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。

   通过继承来实现复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类。由于基类的内部细节通常对子类来说是可见的，所以这种复用又称「白箱」复用，如果基类发生改变，name子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用。

   由于组合/聚合关系可以将已有的对象（也称成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样可以使得成员对象的内部实现细节对于新对象不可见，成为「黑箱」复用。相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。

   一般而言，如果两个类之间是"Has-A"的关系，应该使用组合或聚合；如果是"Is-A"关系，应该使用继承。

7. ### 迪米特法则Law of Demeter, LoD

   ##### 最少知道原则Least Knowledge Principle, LKP

   ##### 一个软件实体应当尽可能少地与其他实体发生相互作用。

   ##### 一个对象应该对其他对象保持最少的了解。

   迪米特法则要求限制软件实体之间通信的宽度和深度。可以降低系统的耦合度，使类与类之间保持松散的耦合关系。

   迪米特法则有几种定义形式，包括：不要和「陌生人」说话，只与直接朋友通信，「朋友」包括以下几类：

   (1)当前对象本身(this)；

   (2)以参数形式传入到当前对象方法中的对象；

   (3)当前对象的成员对象；

   (4)如果当前对象的成员对象是一个集合，那么集合中的元素都是朋友；

   (5)当前对象所创建的对象。

   应该尽量减少对象之间的交互，如果其中一个对象需要调用另一个对象的某一个方法，可以通过第三者转发这个调用。简言之，及时通过引入一个合理的第三者来降低现有对象之间的耦合度。

   注意：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合的类一旦被修改，不会对关联的类造成太大影响；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。

