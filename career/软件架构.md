**软件架构**

****没有银弹****
没有「普适性」的解决方案。尽可能地了解不同的方法，理解每一种方法的优劣，以及他们解决的特定技术问题。

****术语****
功能性(Functional)
在应用中纯粹发挥技术作用的代码片段、方法、类、类的组合。它们和（业务）领域无关，仅代表应用中的一种技术能力。例如：
- 层次(Layer)
- 工厂(Factory)
- 资源库(Repository)
- 值对象(Value Object)
- 视图(View)
- 视图模型(View Model)

概念性(Conceptual)
在应用中标识一个（业务）领域概念的代码片段、方法、类、类的组合。和领域相关，代表应用中的一种业务能力。例如：
- 用户
- 产品
- 库存管理
- 结账
- 销售

这种划分并不是说一个代码单元不能同时具备两种能力(功能性和概念性)。例如，“Money”对象可以表示一个领域概念，同时也被设计成一个值对象。如果我把它当成领域概念，我指的就是领域内的金钱概念，但如果我涉及的是这个类中的功能性方面时，我指的就是值对象的技术特性(没有ID、可以是不变的等等)。

包(Package)
划分在一起的类组成的集合，理想情况下遵循一组规则。

模块(Module)
Software Architecture in Practice 模块就是一个功能性包，它体现了应用的一种技术能力。它是解耦的，并且能够被其他的实现替换。模块提供的是功能性内聚。

组件(Component)
一个代表业务能力的概念性包。理想情况下是和其它组件和模块解耦的。例如「用户」、「产品」或「结账」。
然而，理想情况下，他代表一个界限上下文(Bounded Context)。组件提供概念性内聚。

应用(Application)
面向用户的代码，即UI视为应用，它建立在组件之上。

系统(System)
一组以某种方式在一起工作，为各种企业必需品提供功能，形成一个企业范围内的系统，即企业应用。这些应用可能构建在相同或不同的组件上。

架构(Architecture)
软件架构是系统需要考虑的一组结构，它们包括软件元素和它们之间的关系，以及这些元素和关系的属性。—— Clements et al, 2010

下面是我考虑架构的方面：

- 横跨所有特性开发的技术决策，例如，框架、代码标准、文档、流程，...；

- 这是存在于项目中的一组很难在后期改变的技术决策；

- 它是系统的全景图，粗略的描绘，结构，组件及其关系;

- 它使项目做好变化的准备，常常是将决策推迟到最后允许的时刻；

- 它让项目做好重用组件和模块的准备；

- 它制定出结果的一致性标准并建立轻量的流程，比如编码规范、开发阶段、持续交付和持续部署；

- 它不是某一个人的职责，而是由来自项目中不同特性团队的开发者组成的行会的职责。

架构师(Architect)
他是由行会讨论和决定的架构的发起人和守护者。他是部门/团队中经验最丰富的开发者之一，恰好承担着分析高层次问题和解决方案的额外职责。在做出架构决策时，他还拥有「质量票」。
可是，有一点值得注意，所有开发者某种程度上都是架构师，因为他们都要了解架构，他们都会议某种形式参与架构，他们都适当地承担着维护架构的职责。

象牙塔架构师(Ivory Tower Architect)
有一种架构师会做出和架构有关的所有决定，这种万能的象牙塔架构师是一种架构师的反模式。他对其他干系人对架构的贡献既不开放，也不轻易接收，而是阉割了这些贡献。

****架构的坏味道****

僵化(Rigidity)
如果软件难以修改是因为修改会导致更多关联修改，软件就是僵化的。它就会变成兔子洞：当我们以为修改快要完成时，突然发现还有更多的代码需要修改，把我们拉进无止尽的轮回之中。

脆弱(Fragility)
脆弱的软件在修改时，总会出现意料之外的、毫无关联的、无法预测的错误。

牢固(Immobility)
如果设计包含一些可以在其它系统中使用的部分，但将这些部分从原系统中分离出来需要大量工作甚至带来许多风险，我们就说设计是牢固的。

粘滞(Viscosity)
在一个粘滞的系统中，要做对困难重重，要做错却轻而易举。这意味着通过正常开发实现变更不如用非常手段来得容易。

如果执行单元测试和/或编译需要耗费很长时间，开发很可能导跳过这些过程，不跑任何自动化测试就实现非常规的修改，这就是系统范围的粘滞。

不必要的重复(Needless repetition)
当时间不够或经验不足导致必要的抽象缺失时，就会产生不必要的重复。这些代码也许并不是直接复制粘贴造成的重复，而是由在不同地方重复定义的相同业务规则带来的。

晦涩(Opacity)
代码写得混乱，难以理解，我们需要深人方法实现的细节才能搞清楚代码要干什么。

不必要的复杂(Needless complexity)
开发者采用了多种不同的抽象和未来潜在变化的应对措施，来积极地避免其他六种坏味道。良好的软件设计是轻量灵活的，理解起来更容易，最重要的是修改更容易，因此不必预判所有未来的潜在变化。
