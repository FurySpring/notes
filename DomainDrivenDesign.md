1. `DDD`中心思想：关注精简的业务模型及实现的匹配。
2. 软件和领域：让软件成为领域的反射（映射）。
3. 软件的最终目的是去解决真实领域中的业务问题，所以它必须和领域完美结合。
4. **模型**是对目标领域内部的展现方式，它是必须的，会贯穿设计和开发的全过程。
5. 我们需要用模型来交流。
6. 通常，软件架构师或开发人员都会和领域专家进行很长时间的讨论。软件专家希望从领域专家那里获取知识，他们也不得不将他们转换成有用的形式。
6. 领域驱动设计的一个核心的原则是使用一种基于模型的语言。因为模型是软件满足领域的共同点，它很适合作为这种通用语言的构造基础。
7. 使用模型作为语言的核心骨架。要求团队在所有的交流中都是使用一致的语言，在代码中也是这样。这种语言被称为**通用语言**（Ubiquitous Language）。
8. 强烈建议开发人员把模型中的主要概念实现到代码中。通过为模型概念建立对应的类，我们在模型和代码之间以及在语言和代码之间做映射。这非常有帮助，它会让代码更可读，让模型得到完美实现。
9. `UML`图在只涉及少量元素时很有帮助。同时`UML`擅长表现类，他们的属性和相互之间的关系。但类的行为和约束并不容易表现。所以`UML`不能传达一个模型很重要的两个方面：它所要表现的概念的意义和对象准备做什么。
10. 我们可以使用文档。一个明智的沟通模型的方式是创建一些小的图，让每幅小图包含模型的一个子集。这些图会包含若干类以及它们之间的关系。然后我们可以向图中添加文本。
11. 如何处理从模型到代码的转换？一个推荐的设计技巧是使用分析模型，它被认为是从代码设计中分离出来、通常是由多个人完成的。这个方法存在的一个主要问题是分析不能预见模型中存在的某些缺陷以及领域中的所有复杂关系。一个更好的方法是紧密关联领域建模和设计。模型在构建时就考虑到软件和设计。开发人员会加入到建模的过程中。
13. 将一个复杂的程序切分成层。开发每一个层中内聚设计，让每个层仅依赖于它底下的那层。遵照标准的架构模式以提供层的低耦合。将领域模型相关的代码集中到一个层中，把它从用户界面、应用和基础设施中分割开来。释放领域对象的显示自己、保存自己、管理应用任务等职责，让它专注于展现领域模型。这会让一个模型进一步富含知识，更清晰地捕获基础的业务知识，让它们正常工作。
14. 一个通用领域驱动设计的架构性解决方案包含4个概念层：

- **用户界面/展现层**：负责相互用展现信息以及解释用户命令
- **应用层**：很薄的一层，用来协调应用的活动。它不包含业务逻辑、不保留业务对象的状态，但它保有应用任务的进度状态。
- **领域层**：包含领域的信息。这是业务软件的核心。这里保留业务对象的状态，对业务对象和他们状态的持久化被委托给了基础设施层。
- **基础设施层**：作为其它层的支撑库。它提供了层间的通信，实现对业务对象的持久化，包含对用户界面层的支撑库等作用。

15. **实体**：有一类对象看上去好像拥有标识符，它的标识符在历经软件的各种状态后仍能保持一致。对这些对象来讲这已经不再是它们关心的属性，这意味着能够跨越系统的生命周期甚至能超越软件系统的一系列的延续性和标识符。
16. 因此，在软件中实现实体意味着创建标识符。通常标识符或是对象的一个属性（或属性的组合），一个专门为保存和表现标识符而创建的属性，也或是一种行为。
17. 当一个对象可以用其标识符而不是它的属性来区分时，可以将它作为模型中的主要定义。保证类定义简洁并关注生命周期的延续性和可标识性；对每个对象定义有一个有意义的区分，而不管它的形式或者历史；警惕要求使用属性匹配对象的需求。定义一个可以保证对每一个对象产生一个唯一的结果的操作，这个过程可能需要某个符号以保证唯一性。
18. **值对象**：我们对某个对象是什么不感兴趣，只关心它拥有的属性。用来描述领域的特殊方面，且没有标识符的一个对象。
19. 极力推荐值对象是不变的。如果值对象是可共享的，那么它们应该是不可变的。值对象应该保持尽量的简单。
20. 值对象可以包含其他的值对象，它们甚至还可以包含对实体对象的引用。
21. **服务**：有些领域中的动作，它们是一些动词，看上去却不属于任何对象。它们代表了领域中的一个重要的行为，所以不能忽略它们或者简单的把它们合并到某个实体或者值对象中。当这样的行为从领域中被识别出来时，最佳的实践是将它声明成一个服务。这样的对象不再拥有内置的状态，它的作用是为了简化所提供的领域功能。
22. 服务所能提供的协调作用是非常重要的，一个服务可以将服务于实体和值对象的相关功能分组。服务担当了一个提供操作的接口。一个服务不是在执行服务的对象，而与被执行操作的对象相关。
23. 当一个操作凸现为一个领域中的重要概念时，就需要为它建立一个服务。
24. 服务的特征：
    1. 服务执行的操作涉及一个领域概念，这个领域概念通常不属于一个实体或者值对象。
    2. 被执行的操作涉及到领域中的其他对象。
    3. 操作是无状态的。
25. 不论是应用服务还是领域服务，通常都是建立在领域实体和值对象的上层，以便直接为这些相关的对象提供所需的服务。决定一个服务所应归属的层是非常困难的事情。如果所执行的操作概念上属于领域层，那么服务就应该放到这个层。如果操作和领域对象相关，而且确实也跟领域相关，能够满足领域的需要，那么它就应该属于领域层。
26. **模块**：模块被用来作为组织相关概念和任务以便降低复杂性的一种方法。强烈推荐将高关联度的类分组到一个模块以提供尽可能大的内聚。
    1. **通信性内聚**：通常在模块的部件操作相同的数据时使用，它们之间存在很强的关联性。
    2. **功能性内聚**：在模块中的部件协同工作以完成定义好的任务时使用。
27. **聚合**：聚合是一个定义对象所有权和边界的领域模式。工厂和资源库是另外两个设计模式，用来处理对象的创建和储存问题。
28. 多对多的关联处理：
    1. 要删除模型中非本质的关联关系；
    2. 可以通过增加约束的方式来消减多重性；
    3. 很多时候双向关联可以被转换成非双向的关联。
29. 聚合是针对数据变化可以考虑成一个单元的一组相关的对象。聚合使用边界内部和外部的对象划分开来。每个聚合有一个根。这个跟是一个实体，并且它是外部可以访问的唯一的对象。根可以保持对任意聚合对象的引用，并且其他的对象象可以持有任意其他的对象，但一个外部对象只能持有根对象的引用。如果边界内有其他的实体，那些实体的标识符是本地化的，只在聚合内有意义。
30. 聚合内的对象可以被允许持有对其他聚合根的引用。根实体拥有全局的标识符，并且有责任管理不变量。内部的实体拥有内部的标识符。
31. 将有关的实体和值对象放置到聚合中并且围绕它们定义边界。选择一个实体作为每个聚合的根，并且通过根来控制所有对边界内的对象的访问。允许外部对象仅持有对根的引用。临时对内部成员的引用仅可以被传递给一个单独的操作使用。
32. **工厂**：一个对象的创建可能是它自身的主要操作，但是复杂的组装操作不应该成为被创建对象的职责。因此，有必要引入一个新的概念，帮助封装复杂的对象创建过程，他就是工厂（Factory）。当聚合的根建立时，所有聚合包含的对象将随之建立，所有的不变量得到了强化。
33. 两种设计模式：工厂方法和抽象工厂。
    1. 工厂方法是一个对象的方法，包含并隐藏了必要的创建其他对象的知识。解决方案是给聚合的根增加一个方法，这个方法非常关心对象的创建，强化所有的不变量，返回对那个对象的引用或者拷贝。
34. 当创建一个工厂时，我们被迫违反一个对象的封装原则。实体工厂和值对象工厂是有差异的。值通常是不可变的对象，并且其所有的必需的属性需要在创建时完成。当一个对象被创建时，它是有效的，也是最终的，不会再发生变化。实体是非不可变的。它们会在以后发生变化，前面提及过设置某些属性时需要考虑所有的不变量。另一个差异源于实体需要标识符，而值对象不需要。
35. 构造函数使用情况：
    - 构造过程并不复杂；
    -  对象的创建不涉及到其他对象的创建，所有的属性需要传递给构造函数；
    -  客户程序对实现很感兴趣，可能希望选择使用策略模式；
    -  类是特定的类型，不涉及到继承，所以不用在一些列的具体实现中选择。
36. **资源库**：使用一个资源库，它的目的是封装所有获取对象引用所需的逻辑。领域对象不需要处理基础设施，以得到领域中对其他对象的所需引用。只需要从资源库中获取它们，于是模型重获他应有的清晰和焦点。换种说法是：资源库作为一个全局的可访问对象的存储点而存在。
37. 工厂和资源库之间存在一定的关系。
    1. 它们都是模型驱动设计中的模式，他们都能帮助我们关联领域对象的生命周期。
    2. 然而工厂关注的是对象的创建，而资源库关心的是已经存在的对象。
    3. 工厂创建新的对象，而资源库应该是用来发现已经创建过的对象。
    4. 另外需要注意的是“纯的领域”，而资源库会包含对基础设施的连接，如数据库。
38. **重构**：重构是不改变应用行为而重新设计代码以让它更好的过程。从传统意义上讲，重构描述的是从技术动机的代码转换。重构同样可以由对领域的深入理解，以及对模型及其代码表达进行相应的精化所推动。
39. 为达到一次突破，我们需要让隐式的概念现实化。显式化过程常用概念：
    1. **约束**：约束是一个很简单的表示不变量的方式。无论对象的数据是否发生了变化，都要考虑不变量。
    2. **过程**：过程通常在代码中被表现为procedure。从我们开始使用面向对象语言后就不再用一个过程化的方法，所以我们需要为过程选择一个对象，然后给它增加行为。最好的实现过程的方式是使用服务。
    3. **规约**：简单地说，规约是用来测试一个对象是否满足特定条件的。领域层包含了应用到实体和值对象上的业务规则。规则应该被封装到一个负责它的对象中，这将成为客户的规约，并且被保留在领域层中。通常情况下，一个单个的规约负责检查是否满足一个简单的规则，若干个这样的规约组合在一起表现一个复杂的规约。
40. **界定的上下文**：当我们开发大的企业应用时，需要为每一个我们创建的模型定义上下文。尽量把那些相关联的以及能形成一个自然概念的因素放在一个模型里。模型应该足够小，以便能分给一个团队去实现。模型的上下文是一个条件集合，用这些条件可以确保在模型里的条款都有一个明确的含义。
41. 这儿主要的思想是定义模型的范围，画出它的上下文的边界，然后尽最大可能保持模型的一致性。被界定的上下文不是模型。界定的上下文提供有模型参与的逻辑框架。模块被用来组织模型的要素，因此界定的上下文包含模块。
42. **持续集成**：持续集成是基于模型中概念的集成，然后再通过测试实现。任何不完整的模型在实现过程中都会被检测出来。持续集成用于界定的上下文，不会被用来处理相邻上下文之间的关系。
43. **上下文映射**：一个企业应用有多个模型，每个模型有自己的界定的上下文。建议用上下文作为团队组织的基础。
    1. 一个通常的做法是先定义上下文，然后为每个上下文创建模型，再用一个约定的名称指明每个模型所属的上下文。
    2. 在上下文之间，**共享内核**（Shared Kernel）和**客户-供应商**（Customer-Supplier）是具有高级交互的模式。隔离通道（Separate Way）是在我们想让上下文高度独立和分开运行时要用到的模式。还有两个模式处理系统和继承系统或者外部系统之间的交互，它们是开放主机服务（Open Host Service）和防崩溃层（Anticorruption Layer）。
44. **共享内核**：需要指派两个团队统一共享的领域模型子集。共享内核的目的是减少重复，但是仍保持两个独立的上下文。
45. **客户-供应商**：两个子系统之间的接口需要预先明确定义。在两个团队之间确定一个明显的客户-供应商关系。如果客户不得不使用供应商团队的模型，而且这个模型做得很好，那么就需要顺从。客户团队遵从供应商团队的模型，完全顺从它。和共享内核类似，但是客户团队不能对内核做更改。
46. **防崩溃层**：在我们的模型和遗留模型之间需要有一个集成层，这也是使用旧应用的需求之一。应该在我们的客户端模型和外部模型之间建立一个防崩溃层。
47. #page 70#