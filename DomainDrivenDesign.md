1. `DDD`中心思想：关注精简的业务模型及实现的匹配。
2. 软件和领域：让软件成为领域的反射（映射）。
3. 软件的最终目的是去解决真实领域中的业务问题，所以它必须和领域完美结合。
4. **模型**是对目标领域内部的展现方式，它是必须的，会贯穿设计和开发的全过程。
5. 我们需要用模型来交流。
6. 通常，软件架构师或开发人员都会和领域专家进行很长时间的讨论。软件专家希望从领域专家那里获取知识，他们也不得不将他们转换成有用的形式。
6. 领域驱动设计的一个核心的原则是使用一种基于模型的语言。因为模型是软件满足领域的共同点，它很适合作为这种通用语言的构造基础。
7. 使用模型作为语言的核心骨架。要求团队在所有的交流中都是使用一致的语言，在代码中也是这样。这种语言被称为**通用语言**（Ubiquitous Language）。
8. 强烈建议开发人员把模型中的主要概念实现到代码中。通过为模型概念建立对应的类，我们在模型和代码之间以及在语言和代码之间做映射。这非常有帮助，它会让代码更可读，让模型得到完美实现。
9. `UML`图在只涉及少量元素时很有帮助。同时`UML`擅长表现类，他们的属性和相互之间的关系。但类的行为和约束并不容易表现。所以`UML`不能传达一个模型很重要的两个方面：它所要表现的概念的意义和对象准备做什么。
10. 我们可以使用文档。一个明智的沟通模型的方式是创建一些小的图，让每幅小图包含模型的一个子集。这些图会包含若干类以及它们之间的关系。然后我们可以向图中添加文本。
11. 如何处理从模型到代码的转换？一个推荐的设计技巧是使用分析模型，它被认为是从代码设计中分离出来、通常是由多个人完成的。这个方法存在的一个主要问题是分析不能预见模型中存在的某些缺陷以及领域中的所有复杂关系。一个更好的方法是紧密关联领域建模和设计。模型在构建时就考虑到软件和设计。开发人员会加入到建模的过程中。
13. 将一个复杂的程序切分成层。开发每一个层中内聚设计，让每个层仅依赖于它底下的那层。遵照标准的架构模式以提供层的低耦合。将领域模型相关的代码集中到一个层中，把它从用户界面、应用和基础设施中分割开来。释放领域对象的显示自己、保存自己、管理应用任务等职责，让它专注于展现领域模型。这会让一个模型进一步富含知识，更清晰地捕获基础的业务知识，让它们正常工作。
14. 一个通用领域驱动设计的架构性解决方案包含4个概念层：

- **用户界面/展现层**：负责相互用展现信息以及解释用户命令
- **应用层**：很薄的一层，用来协调应用的活动。它不包含业务逻辑、不保留业务对象的状态，但它保有应用任务的进度状态。
- **领域层**：包含领域的信息。这是业务软件的核心。这里保留业务对象的状态，对业务对象和他们状态的持久化被委托给了基础设施层。
- **基础设施层**：作为其它层的支撑库。它提供了层间的通信，实现对业务对象的持久化，包含对用户界面层的支撑库等作用。

15. **实体**：有一类对象看上去好像拥有标识符，它的标识符在历经软件的各种状态后仍能保持一致。对这些对象来讲这已经不再是它们关心的属性，这意味着能够跨越系统的生命周期甚至能超越软件系统的一系列的延续性和标识符。
16. 因此，在软件中实现实体意味着创建标识符。通常标识符或是对象的一个属性（或属性的组合），一个专门为保存和表现标识符而创建的属性，也或是一种行为。
17. 当一个对象可以用其标识符而不是它的属性来区分时，可以将它作为模型中的主要定义。保证类定义简洁并关注生命周期的延续性和可标识性；对每个对象定义有一个有意义的区分，而不管它的形式或者历史；警惕要求使用属性匹配对象的需求。定义一个可以保证对每一个对象产生一个唯一的结果的操作，这个过程可能需要某个符号以保证唯一性。
18. **值对象**：我们对某个对象是什么不感兴趣，只关心它拥有的属性。用来描述领域的特殊方面，且没有标识符的一个对象。
19. 极力推荐值对象是不变的。如果值对象是可共享的，那么它们应该是不可变的。值对象应该保持尽量的简单。
20. 值对象可以包含其他的值对象，它们甚至还可以包含对实体对象的引用。
21. **服务**：有些领域中的动作，它们是一些动词，看上去却不属于任何对象。它们代表了领域中的一个重要的行为，所以不能忽略它们或者简单的把它们合并到某个实体或者值对象中。当这样的行为从领域中被识别出来时，最佳的实践是将它声明成一个服务。这样的对象不再拥有内置的状态，它的作用是为了简化所提供的领域功能。
22. 服务所能提供的协调作用是非常重要的，一个服务可以将服务于实体和值对象的相关功能分组。服务担当了一个提供操作的接口。一个服务不是在执行服务的对象，而与被执行操作的对象相关。
23. 当一个操作凸现为一个领域中的重要概念时，就需要为它建立一个服务。
24. 服务的特征：
    1. 服务执行的操作涉及一个领域概念，这个领域概念通常不属于一个实体或者值对象。
    2. 被执行的操作涉及到领域中的其他对象。
    3. 操作是无状态的。
25. 不论是应用服务还是领域服务，通常都是建立在领域实体和值对象的上层，以便直接为这些相关的对象提供所需的服务。决定一个服务所应归属的层是非常困难的事情。如果所执行的操作概念上属于领域层，那么服务就应该放到这个层。如果操作和领域对象相关，而且确实也跟领域相关，能够满足领域的需要，那么它就应该属于领域层。
26. **模块**：模块被用来作为组织相关概念和任务以便降低复杂性的一种方法。强烈推荐将高关联度的类分组到一个模块以提供尽可能大的内聚。
    1. **通信性内聚**：通常在模块的部件操作相同的数据时使用，它们之间存在很强的关联性。
    2. **功能性内聚**：在模块中的部件协同工作以完成定义好的任务时使用。
27. **聚合**：聚合是一个定义对象所有权和边界的领域模式。工厂和资源库是另外两个设计模式，用来处理对象的创建和储存问题。
28. 多对多的关联处理：
    1. 要删除模型中非本质的关联关系；
    2. 可以通过增加约束的方式来消减多重性；
    3. 很多时候双向关联可以被转换成非双向的关联。
29. 聚合是针对数据变化可以考虑成一个单元的一组相关的对象。聚合使用边界内部和外部的对象划分开来。每个聚合有一个根。这个跟是一个实体，并且它是外部可以访问的唯一的对象。根可以保持对任意聚合对象的引用，并且其他的对象象可以持有任意其他的对象，但一个外部对象只能持有根对象的引用。如果边界内有其他的实体，那些实体的标识符是本地化的，只在聚合内有意义。
30. 聚合内的对象可以被允许持有对其他聚合根的引用。根实体拥有全局的标识符，并且有责任管理不变量。内部的实体拥有内部的标识符。
31. 将有关的实体和值对象放置到聚合中并且围绕它们定义边界。选择一个实体作为每个聚合的根，并且通过根来控制所有对边界内的对象的访问。允许外部对象仅持有对根的引用。临时对内部成员的引用仅可以被传递给一个单独的操作使用。
32. **工厂**：一个对象的创建可能是它自身的主要操作，但是复杂的组装操作不应该成为被创建对象的职责。因此，有必要引入一个新的概念，帮助封装复杂的对象创建过程，他就是工厂（Factory）。当聚合的根建立时，所有聚合包含的对象将随之建立，所有的不变量得到了强化。
33. 两种设计模式：工厂方法和抽象工厂。
    1. 工厂方法是一个对象的方法，包含并隐藏了必要的创建其他对象的知识。解决方案是给聚合的根增加一个方法，这个方法非常关心对象的创建，强化所有的不变量，返回对那个对象的引用或者拷贝。
34. 当创建一个工厂时，我们被迫违反一个对象的封装原则。实体工厂和值对象工厂是有差异的。值通常是不可变的对象，并且其所有的必需的属性需要在创建时完成。当一个对象被创建时，它是有效的，也是最终的，不会再发生变化。实体是非不可变的。它们会在以后发生变化，前面提及过设置某些属性时需要考虑所有的不变量。另一个差异源于实体需要标识符，而值对象不需要。
35. 构造函数使用情况：
    - 构造过程并不复杂；
    -  对象的创建不涉及到其他对象的创建，所有的属性需要传递给构造函数；
    -  客户程序对实现很感兴趣，可能希望选择使用策略模式；
    -  类是特定的类型，不涉及到继承，所以不用在一些列的具体实现中选择。
36. **资源库**：使用一个资源库，它的目的是封装所有获取对象引用所需的逻辑。领域对象不需要处理基础设施，以得到领域中对其他对象的所需引用。只需要从资源库中获取它们，于是模型重获他应有的清晰和焦点。换种说法是：资源库作为一个全局的可访问对象的存储点而存在。
37. #page51#